interface SourceRef {
    symbol: string;
    line?: number;
    index?: number;
    path?: string;
}

declare abstract class FxExpression {
    private readonly _scope;
    sourceRef: SourceRef;
    protected constructor();
    protected get children(): FxExpression[];
    get scope(): FxScope;
    evaluate(): any;
    bindScope(parent?: FxScope): void;
    toString(): string;
}

declare class FxScopeVariable extends FxExpression {
    private readonly _fxScopeVariableExpressionType;
    readonly varName: string;
    protected readonly inner: FxExpression;
    protected readonly canCache: boolean;
    protected readonly dependents: FxScopeVariable[];
    protected cachedValue: any;
    protected isCached: boolean;
    constructor(name: string, inner: FxExpression, canCache: boolean);
    evaluate(): any;
    clearCache(): void;
    bindScope(root?: FxScope): void;
    addDependents(dependents: FxScopeVariable[]): void;
}

declare class FxScope {
    readonly owner: FxExpression;
    parentScope: FxScope;
    variables: {
        [index: string]: FxScopeVariable;
    };
    constructor(owner?: FxExpression);
    getVariable(key: string): FxScopeVariable;
    setVariable(value: FxScopeVariable): void;
    clearVariables(): void;
    bind(): void;
}

declare class FxNode {
    private _parent;
    private readonly _children;
    constructor();
    get parent(): this;
    set parent(parent: this);
    get children(): this[];
    get count(): number;
    get first(): this;
    get last(): this;
    add(item: FxNode, at?: number | FxNode): void;
    remove(at?: number | FxNode): FxNode;
    orphan(): void;
    wrap(wrapper: FxNode): void;
    unwrap(): void;
    private toIndex;
}

declare type FxTokenTag = "" | "global" | "identifier" | "variable" | "numeric" | "indexer" | "key-indexer" | "group" | "group-close" | "literal" | "space" | "template" | "template-call" | "args" | "array" | "operator" | "expression" | "object" | "dynamic";

interface FxToken {
    tag: FxTokenTag;
    symbol?: string;
    line?: number;
    index?: number;
    children?: FxToken[];
}

declare class FxTokenNode extends FxNode implements FxToken {
    tag: FxTokenTag;
    symbol: string;
    sourceRef: SourceRef;
    definition: FxDefinition;
    constructor(tag?: FxTokenTag, symbol?: string, line?: number, index?: number);
    get operator(): FxOperatorDefinition;
    set operator(operator: FxOperatorDefinition);
    get evaluator(): FxEvaluatorDefinition;
    set evaluator(evaluator: FxEvaluatorDefinition);
    optimize(): void;
    validate(): void;
    compile(): FxExpression;
    is(tag: FxTokenTag | FxTokenTag[], symbol?: string | string[]): boolean;
    below(tag: FxTokenTag | FxTokenTag[], symbol?: string | string[]): boolean;
    static from(token: FxToken): FxTokenNode;
    toString(recursive?: boolean, indent?: number): string;
}

declare type AnyFn = (...args: any[]) => any;
interface FxDefinition {
    operator?: FxOperatorDefinition;
    evaluator?: FxEvaluatorDefinition;
    optimizer?: (token: FxTokenNode) => void;
    validator?: (token: FxTokenNode) => void;
    compiler?: (token: FxTokenNode) => FxExpression;
}
interface FxOperatorDefinition {
    readonly symbol: string;
    readonly precedence: number;
    readonly assoc?: "left" | "right";
    readonly isUnary?: boolean;
}
interface FxEvaluatorDefinition {
    readonly name: string;
    evaluate?: AnyFn;
    params?: FxParamDefinition[];
    deferEvaluation?: boolean;
}
interface FxParamDefinition {
    readonly name: string;
    readonly description?: string;
    readonly valueType?: "string" | "number" | "boolean" | "date" | "object" | "array";
}
interface FxExpressionDefinition extends FxEvaluatorDefinition {
    operator?: FxOperatorDefinition;
}
interface FxIntrinsicDefinition extends FxDefinition {
    readonly tag?: FxTokenTag;
}

declare class JsonFx {
    private readonly loader;
    private readonly parser;
    readonly scope: FxScope;
    constructor(...expressions: ReadonlyArray<FxExpressionDefinition>[]);
    compile(template: any): FxCompiledTemplate;
    define(def: FxExpressionDefinition): void;
}
interface FxCompiledTemplate {
    evaluate(...inputs: FxInput[]): any;
    clearInputs(): void;
    toString(): string;
}
interface FxInput {
    name: string;
    value: any;
}

export { AnyFn, FxCompiledTemplate, FxDefinition, FxEvaluatorDefinition, FxExpressionDefinition, FxInput, FxIntrinsicDefinition, FxOperatorDefinition, FxParamDefinition, JsonFx };
